const cds = require('../index'), DEBUG = cds.debug('tx')

class Transaction {

  /**
   * Constructs a new Transaction as a derivate of `srv` (i.e. {__proto__:srv})
   * @param {import('./Service')} srv
   * @returns {Transaction & srv}
   */
  static srv_tx (req, _as_root, srv=this) {
    if (srv._is_tx) return srv
    if (!_is_ctx(req)) return new RootTransaction (srv, new RootContext(req))
    if (_as_root) return new RootTransaction (srv,req)
    const root = req[_context] || req.context || req
    const txs = root.transactions || (root.transactions = new Map)
    return txs.get(srv.name) || new NestedTransaction(srv, req)
  }

  constructor (srv,req) {
    const tx = Object.create(srv)
    const root = tx.context = req.context || req
    const txs = root.transactions || (root.transactions = new Map)
    txs.set(srv.name, tx)
    tx._is_tx = true
    tx._state = 'new' // REVISIT: compat for continue with tx
    if ('begin' in srv) { // queue all further ops behind an initial .begin()
      // REVISIT: move to first non.read db interaction?
      // REVISIT: ready = tx.begin() -> promise must be awaited -> this._busy === true if commit/rollback w/o any runs (cf. cds-runtime/lib/db/Service.js)
      const ready = tx.begin()
      tx.dispatch = async req => { await ready
        delete tx.dispatch
        return tx.dispatch (req)
      }
    }
    return tx
  }

}

class RootTransaction extends Transaction {

  constructor(srv,req) {
    const tx = super(srv,req), proto = new.target.prototype
    tx.commit = proto.commit.bind(tx)
    tx.rollback = proto.rollback.bind(tx)
    return tx
  }

  async commit (res) {
    try {
      if (this.__proto__.commit) await this.__proto__.commit.call(this,res)
      await this.context.emit('succeeded',res)
    } catch(err) {
      await this.rollback(err)
    }
    await this.context.emit('done')
    return res
  }

  async rollback (err) {
    try { // eslint-disable-next-line no-console
      DEBUG && console.trace (
        `\n--------------------------------------------------------\n`,
        `ROLLBACK due to:\n`, err,
        `\n--------------------------------------------------------\n`,
      )
      if (this.__proto__.rollback) await this.__proto__.rollback.call(this,err)
      await this.context.emit('failed',err)
    } finally {
      await this.context.emit('done')
    }
    if (err) throw err
  }
}


class NestedTransaction extends Transaction {

  constructor(srv,req) {
    const tx = super(srv,req), proto = new.target.prototype
    tx.commit = 'commit' in srv ? proto.commit.bind(tx) : _no_commit
    tx.rollback = 'rollback' in srv ? proto.rollback.bind(tx) : _no_rollback
    const root = tx.context = req.context || req
    root.prependOnceListener ('succeeded', ()=>tx.commit())
    root.prependOnceListener ('failed', ()=>tx.rollback())
    if ('end' in srv) root.once ('done', ()=> srv.end())
    return tx
  }

  async commit (res) {
    if (this.__proto__.commit) await this.__proto__.commit.call(this,res)
    return res
  }

  async rollback (err) {
    if (this.__proto__.rollback) await this.__proto__.rollback.call(this,err)
    if (err) throw err
  }

}


const { Context } = cds.Request
const _context = Symbol()
class RootContext extends Context {
  constructor(_){
    super(_)
    if (_) Object.defineProperty(_,_context,{value:this})
  }
}
const _is_ctx = (x) => x && (x[_context] || x instanceof Context)


const _no_commit = (x)=>{ return x }
const _no_rollback = (e)=>{ if (e) throw e }
module.exports = Transaction
