/*
 * input handler on ApplicationService level
 *
 * - remove readonly fields
 * - remove immutable fields on update
 * - add UUIDs
 * - asserts
 */

const getTemplate = require('../utils/template')
const enrichDataWithKeysFromWhere = require('../utils/enrichWithKeysFromWhere')
const generateUUID = require('../utils/uuid')
const elementUtils = require('../utils/element')
const { DRAFT_COLUMNS_MAP } = require('../../common/constants/draft')
const { checkInputConstraints } = require('../../cds-services/util/assert')
const templateProcessor = require('../utils/templateProcessor')

const processorFn = (errors, event) => (row, tKey, element, plain, isRoot) => {
  const category = plain.category
  const val = row && row[tKey]
  // remove readonly & immutable (can also be complex, so do first)
  if (category === 'readonly' || (category === 'immutable' && event === 'UPDATE')) {
    delete row[tKey]
    return
  }

  // generate UUIDs
  if (category === 'uuid' && !val && (event !== 'UPDATE' || !isRoot)) {
    row[tKey] = generateUUID()
    return
  }

  // asserts, if needed
  if (event === 'NEW' || event === 'PATCH') return
  if (val == null && (category !== 'mandatory' || event === 'UPDATE')) return

  // REVISIT: Convert checkInputConstraints to template mechanism
  checkInputConstraints(element, val, errors)
}

// element, target, parent, templateElements
const _pick = element => {
  if (element['@assert.range'] || element['@assert.enum'] || element['@assert.format']) {
    return { category: 'assert' }
  }
  if (elementUtils.isMandatoryField(element)) {
    return { category: 'mandatory' }
  }
  if (elementUtils.isReadOnlyField(element)) {
    return { category: 'readonly' }
  }
  if (element['@Core.Immutable']) {
    return { category: 'immutable' }
  }

  if (element.key && !DRAFT_COLUMNS_MAP[element.name]) {
    // generate uuid
    if (element.type === 'cds.UUID') {
      return { category: 'uuid' }
    }
  }
}

const _callError = (req, errors) => {
  if (errors.length !== 0) {
    for (const error of errors) {
      req.error(error)
    }
  }
}

const _dataFromCQN = query => (query.INSERT && query.INSERT.entries) || (query.UPDATE && query.UPDATE.data)

function _handler (req) {
  if (!req.target) {
    return
  }

  const template = getTemplate('app-input', this, req.target, {
    pick: _pick
  })

  if (template.elements.size === 0) return

  const errors = []

  const data = _dataFromCQN(req.query)

  enrichDataWithKeysFromWhere(data, req.query, req.target)
  const arrayData = Array.isArray(data) ? data : [data]
  for (const row of arrayData) {
    templateProcessor(processorFn(errors, req.event), row, template)
  }
  // REVISIT: REST-Client puts a proxy around req and filters out some data
  // which is used in queries. In the end, req.data is always returned to the user.
  // To incorporate the effects here (generating keys, filtering, ...) one
  // needs to . set req.data to the query-data again.
  if (Array.isArray(req.data)) {
    req.data = req.query.INSERT && req.query.INSERT.entries
  } else {
    req.data = (req.query.INSERT && req.query.INSERT.entries[0]) || (req.query.UPDATE && req.query.UPDATE.data)
  }

  _callError(req, errors)
}

const processorFnForActionsFunctions = (errors, opName) => (row, tKey, element) => {
  const val = row && row[tKey]
  // REVISIT: Convert checkInputConstraints to template mechanism
  checkInputConstraints(element, val, errors, opName)
}
const _processActionFunctionRow = (row, param, key, errors, event, model, service) => {
  const val = row[key]
  if (param._type && param._type.kind === 'entity') {
    const template = getTemplate('app-input', service, param._type, {
      pick: _pick
    })
    if (template.elements.size === 0) return
    const valArray = Array.isArray(val) ? val : [val]
    for (const row of valArray) {
      templateProcessor(processorFnForActionsFunctions(errors, key), row, template)
    }
  } else {
    checkInputConstraints(param, val, errors, key)
  }
}

const _processActionFunction = (row, eventParams, errors, event, model, service) => {
  for (const key of Object.keys(eventParams)) {
    const param = eventParams[key]
    _processActionFunctionRow(row, param, key, errors, event, model, service)
  }
}
const _getEventParameters = (req, service) => {
  // in bound case
  if (req.target) {
    if (req.target.actions && req.target.actions[req.event]) {
      return req.target.actions[req.event].params
    } else {
      return req.target.functions[req.event].params
    }
  } else {
    // in unbound case
    return req._model.definitions[`${service.name}.${req.event}`].params
  }
}
function _actionFunctionHandler (req) {
  const eventParams = _getEventParameters(req, this)
  if (!eventParams) return
  const errors = []
  const data = req.data
  const arrayData = Array.isArray(data) ? data : [data]
  for (const row of arrayData) {
    _processActionFunction(row, eventParams, errors, req.event, req._model, this)
  }
  _callError(req, errors)
}

_handler._initial = true
_actionFunctionHandler._initial = true

module.exports = function () {
  this.before(['CREATE', 'UPDATE', 'NEW', 'PATCH'], '*', _handler)
  const operationNames = []
  for (const operation of this.operations) {
    operationNames.push(operation.name.substring(this.name.length + 1))
  }
  if (operationNames.length > 0) this.before(operationNames, _actionFunctionHandler)

  for (const entity of this.entities) {
    const boundOps = []
    if (entity.actions) {
      boundOps.push(...Object.keys(entity.actions))
    }
    if (entity.functions) {
      boundOps.push(...Object.keys(entity.functions))
    }
    if (boundOps.length > 0) {
      this.before(boundOps, entity.name, _actionFunctionHandler)
    }
  }
}
